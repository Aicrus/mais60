import React, { createContext, useContext, useEffect, useMemo, useState } from 'react';
import { Platform, Linking, Alert, Clipboard } from 'react-native';
import { Pedometer } from 'expo-sensors';
import { Accelerometer } from 'expo-sensors';
import * as Location from 'expo-location';
import * as Battery from 'expo-battery';
import AsyncStorage from '@react-native-async-storage/async-storage';
import Constants from 'expo-constants';
import { useToast } from '@/hooks/useToast';

// FunÃ§Ã£o de ligaÃ§Ã£o simplificada usando apenas Linking (mais confiÃ¡vel)

type SensorsState = {
  stepsToday: number | null;
  accelMagnitude: number | null;
  locationEnabled: boolean | null;
  batteryLevel: number | null; // 0..1
  fallDetectionEnabled: boolean;
  emergencyContact: string | null;

  showFallAlert: boolean;
  setFallDetectionEnabled: (enabled: boolean) => void;
  setEmergencyContact: (contact: string) => void;
  callEmergencyContact: () => void;
  cancelFallAlert: () => void;
};

const SensorsContext = createContext<SensorsState>({
  stepsToday: null,
  accelMagnitude: null,
  locationEnabled: null,
  batteryLevel: null,
  fallDetectionEnabled: false,
  emergencyContact: null,

  showFallAlert: false,
  setFallDetectionEnabled: () => {},
  setEmergencyContact: () => {},
  callEmergencyContact: () => {},
  cancelFallAlert: () => {}
});

export function SensorsProvider({ children }: { children: React.ReactNode }) {
  const [stepsToday, setStepsToday] = useState<number | null>(null);
  const [accelMagnitude, setAccelMagnitude] = useState<number | null>(null);
  const [accelHistory, setAccelHistory] = useState<number[]>([]);
  const [locationEnabled, setLocationEnabled] = useState<boolean | null>(null);
  const [batteryLevel, setBatteryLevel] = useState<number | null>(null);
  const { showToast } = useToast();
  const [batteryWarned, setBatteryWarned] = useState<boolean>(false);

  // Fall detection states
  const [fallDetectionEnabled, setFallDetectionEnabled] = useState<boolean>(false);
  const [emergencyContact, setEmergencyContact] = useState<string | null>(null);
  const [lastAccelValues, setLastAccelValues] = useState<number[]>([]);
  const [fallDetected, setFallDetected] = useState<boolean>(false);

  const [showFallAlert, setShowFallAlert] = useState<boolean>(false);

  // Pedometer
  useEffect(() => {
    let subscription: any = null;
    (async () => {
      try {
        const isAvailable = await Pedometer.isAvailableAsync();
        if (!isAvailable) return;
        const end = new Date();
        const start = new Date();
        start.setHours(0, 0, 0, 0);
        const result = await Pedometer.getStepCountAsync(start, end);
        setStepsToday(result?.steps ?? 0);
        subscription = Pedometer.watchStepCount((res) => {
          setStepsToday((prev) => Math.max(res.steps, prev || 0));
        });
      } catch {}
    })();
    return () => { try { subscription && subscription.remove && subscription.remove(); } catch {} };
  }, []);

  // Accelerometer magnitude mÃ©dia
  useEffect(() => {
    let sub: any;
    try {
      Accelerometer.setUpdateInterval(2000);
      sub = Accelerometer.addListener((data) => {
        const m = Math.sqrt((data?.x || 0) ** 2 + (data?.y || 0) ** 2 + (data?.z || 0) ** 2);

        // Manter histÃ³rico das Ãºltimas 5 leituras para mÃ©dia mÃ³vel
        setAccelHistory(prev => {
          const newHistory = [...prev, m].slice(-5); // Manter apenas as Ãºltimas 5
          const average = newHistory.reduce((a, b) => a + b, 0) / newHistory.length;

          // Atualizar magnitude com mÃ©dia arredondada para 1 casa decimal
          setAccelMagnitude(Number.isFinite(average) ? Number(average.toFixed(1)) : 0);
          return newHistory;
        });
      });
    } catch {}
    return () => { try { sub && sub.remove && sub.remove(); } catch {} };
  }, []);

  // Location (sÃ³ estado de permissÃ£o, sem solicitar ao abrir; pedido ocorre no LocationProvider quando o usuÃ¡rio iniciar o tracking)
  useEffect(() => {
    (async () => {
      try {
        if (Platform.OS === 'web') { setLocationEnabled(false); return; }
        const { status } = await Location.getForegroundPermissionsAsync();
        setLocationEnabled(status === 'granted');
      } catch { setLocationEnabled(false); }
    })();
  }, []);

  // Battery level
  useEffect(() => {
    let sub: any = null;
    (async () => {
      try {
        const level = await Battery.getBatteryLevelAsync();
        setBatteryLevel(level);
        sub = Battery.addBatteryLevelListener(({ batteryLevel }) => setBatteryLevel(batteryLevel));
      } catch {}
    })();
    return () => { try { sub && sub.remove && sub.remove(); } catch {} };
  }, []);

  // Battery low alert (15%)
  useEffect(() => {
    if (batteryLevel == null) return;
    if (!batteryWarned && batteryLevel <= 0.15) {
      showToast({
        type: 'warning',
        message: 'Bateria baixa',
        description: 'Conecte o carregador para nÃ£o interromper suas atividades.',
        position: Platform.OS === 'web' ? 'bottom-right' : 'top',
        duration: 5000,
        closable: true,
      });
      setBatteryWarned(true);
    }
    if (batteryWarned && batteryLevel > 0.20) {
      // Reseta aviso quando subir acima de 20%
      setBatteryWarned(false);
    }
  }, [batteryLevel, batteryWarned, showToast]);

  // Load fall detection settings (only enabled/disabled state from AsyncStorage)
  useEffect(() => {
    (async () => {
      try {
        const enabled = await AsyncStorage.getItem('@fall_detection_enabled');
        setFallDetectionEnabled(enabled === 'true');
      } catch {}
    })();
  }, []);

  // Simplified and more reliable fall detection
  useEffect(() => {
    if (!fallDetectionEnabled || showFallAlert) return;

    let accelSubscription: any = null;
    let fallDetectionBuffer: number[] = [];
    let highImpactDetected = false;
    let stillnessStartTime = 0;
    let monitoringStartTime = 0;

    try {
      Accelerometer.setUpdateInterval(200); // Faster updates for quicker detection
      accelSubscription = Accelerometer.addListener((data) => {
        const magnitude = Math.sqrt((data?.x || 0) ** 2 + (data?.y || 0) ** 2 + (data?.z || 0) ** 2);

        // Maintain buffer of recent readings
        fallDetectionBuffer.push(magnitude);
        if (fallDetectionBuffer.length > 20) {
          fallDetectionBuffer.shift();
        }

        // Only process if we have enough data
        if (fallDetectionBuffer.length < 10) return;

        const recent = fallDetectionBuffer.slice(-5);
        const recentAvg = recent.reduce((a, b) => a + b, 0) / recent.length;

        // Detect high impact (sudden spike) - simplified threshold
        if (!highImpactDetected && recentAvg > 2.5) {
          highImpactDetected = true;
          stillnessStartTime = Date.now();
          monitoringStartTime = stillnessStartTime + 500; // Start monitoring after 0.5s
          console.log('ðŸš¨ IMPACTO DETECTADO:', recentAvg.toFixed(2));
        }

        // If high impact detected, monitor for stillness
        if (highImpactDetected) {
          const currentTime = Date.now();

          // Start monitoring after brief delay
          if (currentTime >= monitoringStartTime && monitoringStartTime > 0) {
            const monitoringTime = Math.round((currentTime - monitoringStartTime) / 1000);

            // Check for stillness (magnitude below 2.5 during monitoring)
            if (recentAvg < 2.5) {
              // If still for 2+ seconds, confirm fall
              if (monitoringTime >= 2 && !fallDetected) {
                console.log('âœ… QUEDA CONFIRMADA! Ligando para emergÃªncia...');
                setFallDetected(true);
                setShowFallAlert(true);
                handleFallDetected();
              }
            } else if (recentAvg > 4.0) {
              // Only reset if movement is very high (indicates normal activity)
              highImpactDetected = false;
              stillnessStartTime = 0;
              monitoringStartTime = 0;
            }
          }

          // Reset everything after 8 seconds total
          if (currentTime - stillnessStartTime > 8000) {
            highImpactDetected = false;
            stillnessStartTime = 0;
            monitoringStartTime = 0;
          }
        }
      });
    } catch {}

    return () => {
      try {
        if (accelSubscription?.remove) accelSubscription.remove();
      } catch {}
    };
  }, [fallDetectionEnabled, fallDetected, showFallAlert]);

  // Handle fall detection - simplified
  const handleFallDetected = () => {
    console.log('ðŸš¨ ALERTA DE QUEDA! Iniciando ligaÃ§Ã£o em 3 segundos...');
    showToast({
      type: 'error',
      message: 'Queda detectada!',
      description: 'Ligando para emergÃªncia em 3 segundos...',
      position: Platform.OS === 'web' ? 'bottom-right' : 'top',
      duration: 3000,
      closable: true,
    });

    // Simple 3-second delay before calling
    setTimeout(() => {
      if (emergencyContact && showFallAlert) {
        console.log('ðŸ“ž Executando ligaÃ§Ã£o de emergÃªncia...');
        callEmergencyContact();
      }
      setShowFallAlert(false);
      setFallDetected(false);
    }, 3000);
  };

  // Cancel fall alert
  const cancelFallAlert = () => {
    setShowFallAlert(false);
    setFallDetected(false);
    showToast({
      type: 'success',
      message: 'Alerta cancelado',
      description: 'A ligaÃ§Ã£o de emergÃªncia foi cancelada.',
      position: Platform.OS === 'web' ? 'bottom-right' : 'top',
      duration: 3000,
      closable: true,
    });
  };

  // Emergency contact functions
  const saveFallDetectionEnabled = async (enabled: boolean) => {
    try {
      await AsyncStorage.setItem('@fall_detection_enabled', enabled.toString());
      setFallDetectionEnabled(enabled);
    } catch {}
  };

  const saveEmergencyContact = async (contact: string) => {
    try {
      // Validate phone number (Brazilian format)
      const cleanNumber = contact.replace(/\D/g, '');
      if (cleanNumber.length < 10 || cleanNumber.length > 11) {
        showToast({
          type: 'error',
          message: 'NÃºmero invÃ¡lido',
          description: 'Digite um nÃºmero de telefone vÃ¡lido com DDD (10 ou 11 dÃ­gitos).',
          position: Platform.OS === 'web' ? 'bottom-right' : 'top',
          duration: 5000,
          closable: true,
        });
        return;
      }

      setEmergencyContact(contact);
    } catch {}
  };

  const callEmergencyContact = async () => {
    if (!emergencyContact) {
      Alert.alert('Erro', 'Nenhum contato de emergÃªncia configurado.');
      return;
    }

    const isExpoGo = Constants.appOwnership === 'expo';
    const isDevelopment = __DEV__;

    let message = `Deseja ligar para ${emergencyContact}?`;
    let confirmButtonText = 'Ligar agora';

    if (isExpoGo) {
      message = `Expo Go: CopiarÃ¡ o nÃºmero ${emergencyContact} para vocÃª ligar manualmente. Continuar?`;
      confirmButtonText = 'Copiar nÃºmero';
    } else if (!isDevelopment) {
      message = `LigaÃ§Ã£o de emergÃªncia para ${emergencyContact}. VocÃª serÃ¡ conectado diretamente. Continuar?`;
    }

    // Primeiro confirmar se o usuÃ¡rio quer ligar
    Alert.alert(
      'Confirmar ligaÃ§Ã£o',
      message,
      [
        { text: 'Cancelar', style: 'cancel' },
        {
          text: confirmButtonText,
          style: 'destructive',
          onPress: async () => {
            await makeEmergencyCall();
          }
        }
      ]
    );
  };

  const makeEmergencyCall = async () => {
    try {
      // Verificar se emergencyContact existe
      if (!emergencyContact) {
        throw new Error('Contato de emergÃªncia nÃ£o configurado');
      }

      // Limpar o nÃºmero de telefone (remover formataÃ§Ã£o)
      const phoneNumber = emergencyContact.replace(/\D/g, '');

      // Validar se Ã© um nÃºmero vÃ¡lido (10 ou 11 dÃ­gitos)
      if (phoneNumber.length < 10 || phoneNumber.length > 11) {
        Alert.alert('NÃºmero invÃ¡lido', 'O nÃºmero deve ter 10 ou 11 dÃ­gitos.');
        return;
      }

      console.log('Iniciando ligaÃ§Ã£o para:', phoneNumber);
      console.log('Plataforma:', Platform.OS);
      console.log('Contato original:', emergencyContact);

      // Mostrar feedback visual antes da ligaÃ§Ã£o
      showToast({
        type: 'info',
        message: 'Ligando...',
        description: `Discando para ${phoneNumber}`,
        position: Platform.OS === 'web' ? 'bottom-right' : 'top',
        duration: 3000,
        closable: true,
      });

      // Criar URL de ligaÃ§Ã£o
      const url = `tel:${phoneNumber}`;
      console.log('URL:', url);

      // Verificar se o dispositivo suporta ligaÃ§Ãµes
      const supported = await Linking.canOpenURL(url);
      console.log('Suportado:', supported);

      if (supported) {
        console.log('Abrindo ligaÃ§Ã£o...');

        // Abrir ligaÃ§Ã£o diretamente
        await Linking.openURL(url);

        // Feedback de sucesso
        setTimeout(() => {
          showToast({
            type: 'success',
            message: 'LigaÃ§Ã£o iniciada!',
            description: 'Verifique seu telefone',
            position: Platform.OS === 'web' ? 'bottom-right' : 'top',
            duration: 5000,
            closable: true,
          });
        }, 2000);

      } else {
        // Se nÃ£o suporta ligaÃ§Ãµes, mostrar alternativas
        await showAlternativeContactOptions(phoneNumber);
      }

    } catch (error) {
      console.error('Erro na ligaÃ§Ã£o:', error);
      await showAlternativeContactOptions(null);
    }
  };

  const copyToClipboard = async (text: string) => {
    try {
      await Clipboard.setString(text);
      showToast({
        type: 'success',
        message: 'NÃºmero copiado!',
        description: `NÃºmero ${text} copiado para Ã¡rea de transferÃªncia`,
        position: Platform.OS === 'web' ? 'bottom-right' : 'top',
        duration: 3000,
        closable: true,
      });
    } catch (error) {
      console.error('Erro ao copiar:', error);
      Alert.alert('Erro', 'NÃ£o foi possÃ­vel copiar o nÃºmero.');
    }
  };

  const showAlternativeContactOptions = async (phoneNumber: string | null) => {
    const isExpoGo = Constants.appOwnership === 'expo';
    const isDevelopment = __DEV__;

    let message = '';
    let actions: any[] = [];

    if (isExpoGo) {
      if (isDevelopment) {
        message = `Ambiente de Desenvolvimento:\n\nPara testar ligaÃ§Ãµes no Expo Go:\n\n1. Copie o nÃºmero abaixo\n2. Abra o app Telefone do seu dispositivo\n3. Cole o nÃºmero e ligue manualmente\n\nPara produÃ§Ã£o: use um build nativo para ligaÃ§Ãµes diretas.`;

        actions = [
          {
            text: 'Copiar nÃºmero',
            onPress: () => {
              if (phoneNumber) {
                copyToClipboard(phoneNumber);
              }
            }
          },
          {
            text: 'Ver instruÃ§Ãµes',
            onPress: () => {
              Alert.alert(
                'Como testar ligaÃ§Ãµes',
                `Para testar ligaÃ§Ãµes de emergÃªncia:\n\n1. Copie o nÃºmero: ${phoneNumber}\n2. Abra o app Telefone\n3. Cole e ligue\n\nOu use um build de desenvolvimento fora do Expo Go.`
              );
            }
          },
          { text: 'Entendi', style: 'cancel' }
        ];
      } else {
        message = `Expo Go nÃ£o suporta ligaÃ§Ãµes diretas.\n\nPara ligar:\nâ€¢ Copie o nÃºmero abaixo\nâ€¢ Ligue manualmente`;

        actions = [
          {
            text: 'Copiar nÃºmero',
            onPress: () => {
              if (phoneNumber) {
                copyToClipboard(phoneNumber);
              }
            }
          },
          { text: 'OK', style: 'cancel' }
        ];
      }
    } else {
      message = `Este dispositivo nÃ£o suporta ligaÃ§Ãµes telefÃ´nicas diretamente.\n\nPara ligar:\nâ€¢ Copie o nÃºmero abaixo\nâ€¢ Abra o app Telefone\nâ€¢ Ligue manualmente\n\nNÃºmero: ${phoneNumber || 'nÃ£o disponÃ­vel'}`;

      actions = [
        {
          text: 'Copiar nÃºmero',
          onPress: () => {
            if (phoneNumber) {
              copyToClipboard(phoneNumber);
            }
          }
        },
        {
          text: 'Abrir Telefone',
          onPress: () => {
            Linking.openURL('tel:').catch(() => {
              Alert.alert('Dica', 'Abra manualmente o app Telefone do seu dispositivo.');
            });
          }
        },
        { text: 'OK', style: 'cancel' }
      ];
    }

    Alert.alert(
      'Como ligar para emergÃªncia',
      message,
      actions
    );
  };

  const value = useMemo(() => ({
    stepsToday,
    accelMagnitude,
    locationEnabled,
    batteryLevel,
    fallDetectionEnabled,
    emergencyContact,

    showFallAlert,
    setFallDetectionEnabled: saveFallDetectionEnabled,
    setEmergencyContact: saveEmergencyContact,
    callEmergencyContact,
    cancelFallAlert
  }), [stepsToday, accelMagnitude, locationEnabled, batteryLevel, fallDetectionEnabled, emergencyContact, showFallAlert]);
  return (
    <SensorsContext.Provider value={value}>
      {children}
    </SensorsContext.Provider>
  );
}

export function useSensors() {
  return useContext(SensorsContext);
}


